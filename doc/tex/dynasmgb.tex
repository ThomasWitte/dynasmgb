\documentclass[a4paper]{scrartcl}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{courier}
\usepackage{listings}

\lstdefinelanguage
   [x64]{Assembler}     % add a "x64" dialect of Assembler
   [x86masm]{Assembler} % based on the "x86masm" dialect
   % with these extra keywords:
   {morekeywords={CDQE,CQO,CMPSQ,CMPXCHG16B,JRCXZ,LODSQ,MOVSXD, %
                  POPFQ,PUSHFQ,SCASQ,STOSQ,IRETQ,RDTSCP,SWAPGS, %
                  LD, LDH, JR, CP, CALL,
                  rax,rdx,rcx,rbx,rsi,rdi,rsp,rbp, %
                  r8,r8d,r8w,r8b,r9,r9d,r9w,r9b}} % etc.

\lstset{ %
  language=[x64]Assembler,       % the language of the code
  basicstyle=\ttfamily,       % the size of the fonts that are used for the code
  %numbers=left,                   % where to put the line-numbers
  %numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  %stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  %numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  %rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
%  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{green},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...},               % if you want to add more keywords to the set
%  
  belowskip=0em,
  aboveskip=2em
}

\title{Entwicklung eines Gameboy-Emulators}
\author{Thomas Witte}
\date{\today}

\begin{document}
\maketitle

\section{Motivation / Emulation}

Der 1989 von Nintendo hergestellte Gameboy ist mit über 100 Millionen verkauften Einheiten eine der erfolgreichsten Spielekonsolen überhaupt.

…
%Warum ist Emulation notwendig
%Was muss emuliert werden
%Interpretation vs jit vs aot
%existierende Gameboy Emulatoren
\section{Gameboy Architektur}

Die folgenden Abschnitte fassen Aufbau und Funktionsweise des klassischen Gameboys zusammen. Auf die Unterschiede zum Gameboy Color und Super Gameboy wird nicht eingegangen.

\subsection{Hardware}

Herzstück des Gameboy ist ein leicht modifizierter Z80 Prozessor, der mit 4,2MHz getaktet ist. Der Registersatz besteht -- ähnlich auch einem Intel 8080 -- aus 7 8bit Registern, einem Flagregister (Zero, Carry, Halfcarry, Subtract) sowie zweier 16bit Register (SP und PC). Die 8bit Register können durch bestimmte 16bit Instruktionen jeweils paarweise als 16bit Register genutzt werden.

Der Gameboy kann auf insgesamt 16kB internen Arbeitsspeicher zugreifen. Dabei sind 8kB dieses Speichers als Tile-RAM für Grafiken zweckgebunden. Der Memory Bank Controller (MBC) bestimmter Spiele kann bis zu 128kB zusätzlichen RAM innerhalb der Cartridge adressieren (16 Bänke à 8kB).

Das Spiel wird direkt aus dem ROM der Spiel-Cartridges gestartet. Über MBCs können dabei maximal 4MB (256 Bänke à 16kB) adressiert werden.

Als Display kommt ein Graustufen-LCD zum Einsatz. Es kann 4 Grautöne darstellen und besitzt eine Auflösung von $160 \times 144$ Pixel bei 60Hz. Die Pixel des Displays können dabei nicht einzeln angesprochen werden, sondern nur in $8 \times 8$ Pixel großen Kacheln (Tiles).

Dabei kann gleichzeitig eine Hintergrundkarte, eine Vordergrundkarte und bis zu 40 Sprites angezeigt werden.

Die Soundausgabe erfolgt über einen integrierten Lautsprecher oder den Kopfhörerausgang in Stereo. Der Gameboy bietet dazu vier Soundkanäle, die Rechteckschwingungen, Rauschen oder Wave-Samples erzeugen bzw. abspielen können.

Zur Eingabe stehen insgesamt acht Knöpfe zur Verfügung (vier Richtungstasten, A, B, Select und Start). Alternativ können Daten über eine serielle Schnittstelle gesendet oder empfangen werden.
%Prozessor, Speicher, Takt, Display, Registersatz, IO ...
\subsection{Befehlssatz}

Der Befehlssatz umfasst insgesamt 500 verschiedene Befehle variabler Instruktionslänge (1-3 Bytes). 244 Befehle nutzen das erste Byte für den Opcode und maximal zwei Bytes für Argumente. Die restlichen 256 Befehle werden durch das Präfixbyte 0xCB eingeleitet und besitzen somit einen 2Byte-Opcode und keine weiteren Argumente.

Die Ausführungszeit der Befehle beträgt jeweils zwischen 4 und 24 Taktzyklen. Damit beträgt der maximale Befehlsdurchsatz 1MOps/s.

Eine Übersicht sämtlicher Befehle befindet sich im Anhang.

%Bild im Anhang, wichtige Instruktionen
\subsection{Interrupts}

Der Gameboy stellt insgesamt fünf verschiedene Interrupts zur Verfügung:

\begin{description}
\item[VBLANK]
Der VBLANK-Interrupt wird nach jedem dargestellten Bild dargestellt und markiert den Beginn der VBLANK-Phase in der für 4560 Taktzyklen frei auf den Videospeicher zugegriffen werden kann.
\item[STAT]
Das STAT-Register (Speicheradresse 0xFF41) wechselt mit jeder dargestellten Bildzeile zwischen drei Zuständen und während der VBLANK-Phase auf einen vierten. Der STAT-Interrupt kann bei einem Wechsel dieser Zustände ausgelöst werden. Welche Zustandsübergänge betroffen sind, kann ausgewählt werden.
\item[Timer]
Der Timer-Interrupt wird bei einem Überlauf des Timer-Registers (0xFF05) ausgelöst. Die Rate mit der das Timer-Register inkrementiert wird ist dabei auswählbar, sodass der Timer-Interrupt mit einer wählbaren Rate von 16Hz, 64Hz, 256Hz oder 1kHz auftritt.
\item[Serial]
Der Serial Transfer-Interrupt wird beim Abschluss eines seriellen Transfers ausgelöst.
\item[Joypad]
Bei jedem Tastendruck eines der acht Knöpfe wird der Joypad-Interrupt ausgelöst.
\end{description}

Tritt ein Interrupt auf, so wird er anhängig und ein Bit im Interrupt Flag-Register (0xFF0F) gesetzt.
Über das Interrupt Enable Register (0xFFFF) kann ausgewählt werden, welche Interrupts aktiv sind.
Das Interrupt Master Enable-Flag kann zusätzlich alle Interrupts abschalten. Es kann durch die Instruktionen DI (Disable Interrupts), EI (Enable Interrupts) oder RETI (Return from Interrupt) manipuliert werden.

Ist ein Interrupt anhängig, das entsprechende Bit im Interrupt Enable Register gesetzt und das Interrupt Master Enable-Flag gesetzt wird eine Handlerfunktion mit fester Startadresse zwischen 0x40 (VBLANK) und 0x60 (Joypad) aufgerufen und mittels des Interrupt Master Enable weitere Interrupts während der Behandlung unterbunden.
%Interrupts, Startadressen, ...
\subsection{Adressraum}

\subsubsection{Memory Map}

Der adressierbare Adressraum des Gameboys beträgt 64kB. In die unteren 32kB (0x0 - 0x7FFF) werden zwei Rombänke à 16kB gleichzeitig eingeblendet. Der Wechsel zwischen den Rombänken geschieht durch den MBC innerhalb der Cartridge. Alle verfügbaren MBCs lösen einen Wechsel der oberen Rombank durch Schreibzugriffe auf bestimmte Adressen im ROM aus.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.75\linewidth]{img/mmap.pdf}
\caption{Visualisierung der oberen 32kB des Adressraums (Pokémon Blaue Edition)}
\label{img:sound}
\end{figure}

Die Adressen zwischen 0x8000 und 0x9FFF bilden den Video-RAM. Er enthält $8 \times 8$ Pixel große Kacheln zu je 16 Byte, sowie Vordergrund und Hintergrund Tile Maps.

Zwischen 0xA000 und 0xBFFF wird der Cartridge RAM eingeblendet. Je nach MBC lassen sich eventuell mehrere Bänke tauschen. Dieser Speicher ist in einigen Spielcartridges durch eine Batterie versorgt und kann damit auch bei ausgeschaltetem Gameboy einen Spielstand halten.

Es folgen 8kB interner RAM (0xC000 - 0xDFFF), der fast vollständig ein zweites Mal im Adressbereich 0xE000 - 0xFDFF gespiegelt wird. Diese Adressen werden jedoch typischerweise nicht verwendet.

Die Adressen 0xFE00 bis 0xFE9F enthalten den OAM Speicher. Er enthält die Position, anzuzeigende Grafik, verwendete Graustufenpalette und Flags aller 40 Sprites. Per DMA-Transfer kann der OAM Speicher nebenläufig überschrieben werden.

Über den Adressbereich 0xFF00 bis 0xFF7F wird der Hardware IO gesteuert. Er enthält Register zur Kontrolle von Timern, Seriellen Übertragungen, DMA-Transfers, Soundausgabe und des anzuzeigenden Mapbereichs.

Im Anschluss befinden sich weitere 127 Byte Arbeitsspeicher (0xFF80 - 0xFFFE), die jederzeit les- und schreibbar sind. Da während eines DMA-Transfers der gesamte sonstige Speicher weder gelesen noch geschrieben werden kann, muss während eines solchen Transfers in diesen Speicherbereich gesprungen werden.

Das Interrupt Enable Register belegt die höchste Adresse 0xFFFF.

\subsubsection{Startadressen}

Die Ausführung des Programms beginnt an Adresse 0x100. Die Handlerfunktionen mit den Startadressen zwischen 0x00 und 0x60 werden durch Restarts und Interrupts angesprungen. 

\subsubsection{ROM-Header}

Die Rom-Adressen 0x104 bis 0x14F sind durch den ROM-Header belegt. Er enthält eine Grafik, die das Nintendo-Logo zeigt (0x104 bis 0x133). Diese wird auf realen Konsolen beim Start angezeigt und verglichen. Stimmt sie nicht exakt überein, startet der Gameboy das Spiel nicht. Die weiteren Bytes enthalten Spieltitel, Hersteller, Flags die anzeigen, ob das Spiel spezielle Funktionen für Gameboy Color oder Super Gameboy enthält, sowie Informationen über den verbauten MBC und die Anzahl der auf der Cartridge vorhandenen RAM- und ROM-Bänke.
%Layout, MBCs, Startsequenz, Memory-Banking, ROM-Header, Spiele speichern
\subsection{Grafik}

Die Pixel des Gameboydisplays können nicht einzeln angesprochen werden, sondern es werden immer ganze Kacheln von jeweils $8 \times 8$ Pixel Größe angezeigt. Neben einer Vordergrund- und Hintergrundkarte (WIN und BG genannt) die die Indizes der anzuzeigenden Kacheln enthalten, können bis zu 40 Sprites frei auf dem Display positioniert werden.

Das Bild wird zeilenweise von oben nach unten aufgebaut. Über das Register LY (0xFF44) kann die derzeit bearbeitete Zeile ausgelesen werden und über das STAT Register (0xFF41) ob derzeit ein Zugriff auf den Grafikspeicher möglich ist.

Die Größe der Vordergrund- und Hintergrundkarte beträgt 32 auf 32 Kacheln, sodass immer nur ein Ausschnitt auf dem Display sichtbar ist. Über die Register SCX (Scroll X, 0xFF43), SCY (Scroll Y, 0xFF42), WX (Window X, 0xFF4B) und WY (Window Y, 0xFF4A) kann der anzuzeigende Bereich gewählt werden. Durch Änderung des sichtbaren Bereichs während des Bildaufbaus können Welleneffekte auf dem Display erzeugt werden.

\begin{figure}[htbp]
\centering
\includegraphics[width=\linewidth]{img/bg_tiles}
\caption{Bestimmung des Helligkeitswerts eines Hintergrundpixels}
\label{img:bg_tiles}
\end{figure}

Abbildung~\ref{img:bg_tiles} zeigt exemplarisch, wie die Farbe eines Hintergrundpixels zustande kommt: zunächst werden für die aktuell gezeichnete Bildzeile die Kachelindizes aus der Background Tile Map bestimmt; diese liegt wählbar entweder ab 0x9800 oder 0x9C00. Über diesen Index wird die Tile Data Table ab 0x8000 oder 0x8800 indiziert. Der Helligkeitswert des $x$-ten Pixels der $y$-ten Kachelzeile kann dann aus dem $x$-ten Bit des $2 \cdot y$-ten und $2 \cdot y+1$-ten Bytes aufgebaut werden. Der Aufbau für ein Vordergrundpixel erfolgt analog.

Bei der Anzeige von Sprites kommt statt einer Tilemap, der OAM-Speicher zum Einsatz: Er enthält für jeden der 40 Sprites eine 4 Byte Struktur, die neben der Bildschrimposition den Kachelindex und einige Flags enthält. Über diese Flags kann der Sprite gespiegelt, hinter dem Hintergrund oder mit einer anderen Graustufenpalette angezeigt werden.
%Timing, Effekte, Speicher, DMA, Tilekodierung, Graustufenpaletten
\subsection{Audio}

Der Gameboy verfügt über vier Kanäle zur Klangerzeugung, die beliebig in die Stereo-Ausgabekanäle gemischt werden können.

Kanal 1 und 2 erzeugen Rechteckschwingungen mit wählbarer Frequenz, Duty-Cycle und linearer Hüllkurve (Abbildung~\ref{img:sound}). Kanal 1 kann zusätlich noch eine Frequenzänderung („Sweep“) eines Tons erzeugen.

\begin{figure}[htbp]
\centering
\includegraphics[width=0.9\linewidth]{img/sound}
\caption{Parameter für die Tonerzeugung auf Kanal 2}
\label{img:sound}
\end{figure}

Kanal 3 kann kann Wave-Samples abspielen. Der Wave-RAM aus dem diese gelesen werden ist auf 32 Samples à 4 Bit beschränkt.

Kanal 4 erzeugt weißes Rauschen. Dabei kann die Rauschcharakteristik beeinflusst werden um „weicheres“ oder „härteres“ Rauschen zu erzeugen.
%Timing, Effekte, Register
\section{Aufbau des jit-Übersetzers}

Für die Emulation der Gameboy Hardware auf herkömmlichen PCs (x86-64 Architektur) wurde ein just-in-time-kompilierender Emulationskern implementiert. Anstatt einzelne Instruktionen in einer Schleife zu dekodieren und interpretieren, wie bei einem interpretierenden Emulator, wird versucht ganze Blöcke, die gewöhnlich mit einer Sprunginstruktion (JP, JR, CALL, RST, RET, RETI) enden, zusammenzufassen. Mittels des Laufzeitassemblers „dynasm“ des Luajit Projekts wird zum ersten Zeitpunkt, zu dem eine Speicheradresse angesprungen wird, dem Block entsprechende x86-Instruktionen erzeugt und ausgeführt.

Ein Ziel bei der Entwicklung war, möglichst die Statusflags (Carry, Halfcarry/Adjust und Zero) der Hostarchitektur für die emulierte Umgebung zu nutzen, anstatt diese zu emulieren. Dies ist in den meisten Fällen problemlos möglich, da sich die Z80-artige Gameboy CPU und die Intel 8080-Architektur, die größtenteils auch von modernen Prozessoren unterstützt wird sehr ähnlich sind. Da das Subtract-Flag des Gameboy keine direkte Entsprechung in der x86-64 Architektur besitzt muss es als einziges der Statusflags emuliert werden.

Sprünge werden nicht direkt ausgeführt, sondern stattdessen das Sprungziel gespeichert und die erzeugte Funktion mit RET verlassen. Dadurch kann die Laufzeitumgebung gegebenenfalls zunächst den Block am Sprungziel übersetzen und andere parallele Aufgaben ausführen. Diese umfassen die Interrupt, Grafik, Eingabe und DMA Emulation\footnote{Die Soundemulation läuft komplett asynchron in einem eigenen Thread und benötigt daher keine Unterbrechung des Programmablaufs.}.

Während der Übersetzung eines Programmblocks wird für jedes mögliche Ende über das der Block verlassen werden kann\footnote{Durch bedingte Sprünge können dies beliebig viele sein.}, die Anzahl der bis zu diesem Punkt benötigten Gameboy-Taktzyklen berechnet und diese Summe bei der Ausführung auf einen Instruktionszähler addiert. Mittels dieses Zählers können auf dem Gameboy zu bestimmten Zeitpunkten auftretende Ereignisse wie Timer- oder VBLANK-Interrupts trotz der höheren Geschwindigkeit der Hostplattform zeitlich genau ausgeführt werden. Da eventuell Routinen in den emulierten Programmen existieren, die auf eine feste Anzahl ausgeführter Instruktionen in einem bestimmten Zeitraum angewiesen sind, können nicht ohne Kompatibilitätsprobleme Timer des Hostsystems benutzt werden. Aufgrund der blockweisen Ausführung besteht jedoch auch bei dem hier vorgestellten Emulator das Problem, dass Interrupts oder Timer erst um einige Takte verspätet -- nach dem nächsten Sprung -- ausgeführt beziehungsweise aktualisiert werden.

Während der Ausführung übersetzter Programmblöcke wird der Registersatz des Gameboy direkt auf Register der x86-64 Architektur abgebildet. Am Ende eines Blocks muss dann der gesamte Gameboy-Registersatz, Prozessorflags und die Anzahl emulierter Taktzyklen gesichert werden (struct gb\_state). Tabelle~\ref{tab:register} stellt die Registernutzung während der Ausführung übersetzter Blöcke dar. Die für die 16 Bit Instruktionen des Gameboy nötigen kombinierten Register AF, BC, DE und HL werden bei Bedarf zunächst in einem temporären Register zusammengesetzt und nach der Instruktion wieder zurückgeschrieben.

\begin{figure}[htbp]
\centering
\begin{tabular}{c|c|c}
Gameboy&Host (x86-64)&Bemerkung \\
\hline
A&r0 (RAX)&Akkumulator \\
F&-&dynamisch aus FLAGS-Register erzeugt \\
B&r1 (RCX)& \\
C&r2 (RDX)&\\
D&r3 (RBX)& \\
E&r13& \\
H&r5 (RBP)&\\
L&r6 (RSI)& \\
SP&r7 (RDI)& \\
PC&-&nicht nötig \\
-&r8&Basisadresse des Gameboy-Adressraums \\
-&r9&Adresse des gb\_state struct \\
-&r10&1. temporäres Register \\
-&r11&2. temporäres Register \\
-&r12&3. temporäres Register \\
-&r4 (RSP)&Host Stack Pointer
\end{tabular}
\caption{Registermapping zwischen Gameboy und Host}
\label{tab:register}
\end{figure}

Ein zweites wichtiges Ziel bei der Implementierung war die Unterstützung direkter lesender Speicherzugriffe: um eine Adresse des Gameboy-Adressraums zu lesen, soll nur eine zusätzliche Addition eines Basiszeigers notwendig sein. Für schreibende Speicherzugriffe ist dies nicht möglich, da Schreibzugriffe auf Adressen im ROM zu Bankwechseln durch den MBC führen und manche IO-Register bei schreibenden Zugriffen bestimmte Aktionen wie DMA-Transfers oder das Lesen der Joypad-Buttons auslösen. Schreibende Zugriffe werden daher durch einen Funktionsaufruf ersetzt, der gegebenenfalls nötige Seiteneffekte emuliert.

Direkte lesende Zugriffe haben einige wichtige Implikationen:
\begin{itemize}
\item Kaum Leseoverhead: Im Vergleich zum Gameboy entsteht bei der Emulation kaum Overhead beim Lesen. Da lesende Speicherzugriffe oft zu den häufigsten Instruktionen gehören, bedeutet dies eine deutliche Effizienzsteigerung.
\item Der emulierte Gameboy-Adressraum muss konsekutiv sein: der Wechsel von ROM- oder RAM-Bänken erfordert einen großen zusätzlichen Aufwand, da zunächst durch munmap und mmap die entsprechende Bank in den Adressraum eingeblendet werden muss.
\item Statusregister müssen immer aktualisiert werden: der Programmablauf muss häufig unterbrochen werden, um spezielle Statusregister, wie den Timer TIMA (0xFF05), oder die aktuell gezeichnete Bildzeile LY (0xFF44) zu aktualisieren. Geschieht dies nicht, terminieren Warteschleifen eventuell nicht mehr.
\end{itemize}

\subsection{Beispielhafte Übersetzung eines Blocks}

Die einzelnen Schritte zur Übersetzung und Ausführung eines Programmblocks sollen durch ein Beispiel verdeutlicht werden: Das folgende Listing zeigt einen Block aus dem Spiel „Super Mario World“.

\begin{lstlisting}
3E 02		LD A, 2
EA 00 20	LD (0x2000), A
E0 FD		LDH (0xFD), A
FA 1D DA	LD A, (0xDA1D)
FE 03		CP A, 3
20 0B		JR NZ, 0xOB
3E FF		LD A, 0xFF
EA 1D DA	LD (0xDA1D), A
CD E8 09	CALL 0x9E8
\end{lstlisting}

Im ersten Schritt werden Instruktionen bis zum Ende des Blocks gelesen. Jeder unbedingte Sprung (JP, CALL, RST, RET, RETI), sowie EI (Enable Interrupts) beenden einen Block. Die Instruktionen werden in einer verketteten Liste gespeichert und nach ihrem Typ gruppiert. Auf diese Instruktionsliste werden verschiedene Regeln zur Optimierung angewendet, sowie Instruktionen zur Speicherung und Wiederherstellung des Statusregisters eingefügt. Danach wird entsprechender x86-64 Assembler generiert -- das Beispiel wird zu folgendem Code übersetzt (ohne Optimierung):

\begin{lstlisting}
	prologue
	mov A, 2
	write_byte 0x2000, A
	write_byte 0xfffd, A
	mov A, [aMem + 0xda1d]
	cmp A, 3
	save_cc
	restore_cc
	jz >1
	add qword state->inst_count, 17
	return 0x239
1:	mov A, 0xff
	write_byte 0xda1d, A
	dec SP
	dec SP
	and SP, 0xffff
	mov word [aMem + SP], 0x235
	add qword state->inst_count, 28
	mov byte state->return_reason, REASON_CALL
	return 0x9e8
\end{lstlisting}

Zur Vereinfachung werden einige Makros verwendet:
\begin{description}
\item[prologue]
sichert alle nötigen Register und stellt die Gameboy-Registerinhalte wieder her.
\item[return]
sichert alle Registerhalte in der gb\_state struct, stellt die ursprünglichen Registerinhalte wieder her, schreibt das Argument in das Ergebnisregister und verlässt die Funktion mit RET.
\item[write\_byte]
ruft die Funktion gb\_memory\_write.
\item[save\_cc]
sichert das Statusregister auf den Stack.
\item[restore\_cc]
stellt das Statusregister vom Stack wieder her.
\end{description}

\emph{aMem} bezeichnet das Register r8, das die Basisadresse des Gameboy-Adressraums enthält, \emph{state} das Register r9, das die Adresse des gb\_state enthält. \emph{state->inst\_count} zählt ausgeführten Gameboy Taktzyklen, \emph{state->return\_reason} gibt an, welche Instruktion den Block beendet, um den Backtrace im Debugger zu aktualisieren.

Im nächsten Schritt wird \emph{dynasm} genutzt um den Code zu assemblieren und in einen vorallokierten Speicherbereich zu schreiben. Nachdem dieser mittels mprotect ausführbar gemacht wurde kann die Funktion ausgeführt werden. Um eine erneute Ausführung zu beschleunigen, wird der Funktionszeiger über die Startadresse indexiert gespeichert. Die durch die Funktion zurückgelieferte Speicheradresse ist die Startadresse des nächsten auszuführenden Blocks\footnote{Tritt ein Interrupt auf, wird sie stattdessen auf den Gameboy-Stack gelegt und die Startadresse des Interrupthandlers angesprungen}.

Wird eine Speicheradresse innerhalb des RAM angesprungen, muss davon ausgegangen werden, dass sich die Instruktionfolge bei der nächsten Ausführung geändert hat. Blöcke innerhalb des RAM werden daher nach der Ausführung wieder verworfen. Eine Ausnahme bilden Blöcke innerhalb der Adressen 0xFF80 bis 0xFFFE: während DMA-Transfers muss kurzzeitig in diesen Bereich gesprungen werden. Die Routine, die auf das Ende des Transfers wartet ändert sich dabei gewöhnlich während der Ausführung des Programms nicht. Es lohnt sich deshalb die Blöcke bis zu einem Schreibzugriff in diesen Speicherbereich zwischenzuspeichern.

\subsection{Optimierung}

Nach dem Lesen eines Instruktionsblocks werden einige Regeln zur Optimierung angewendet. Schleifen unterbrechen durch eine große Anzahl an Sprüngen den Programmablauf sehr häufig und verursachen damit einen sehr hohen Overhead zur Sicherung und Wiederherstellung der Registerinhalte sowie zur Überprüfung auf Interrupts. Aus diesem Grund dienen die meisten implementierten Optimierungen der Erkennung und Behandlung von Schleifen.

Schleifen können am einfachsten an einem Sprung auf die Startadresse des aktuellen Blocks erkannt werden, da spätestens nach der ersten Iteration und dem Rücksprung auf den Schleifenbeginn ein neuer Block ab dieser Startadresse übersetzt wird.

Falls im Schleifenrumpf kein lesender oder schreibender Speicherzugriff stattfindet und alle Interrupts mit RET oder RETI zurückkehren, kann die gesamte Schleife atomar ausgeführt werden. Es ist in diesem Fall unerheblich ob ein Interrupt vor, während oder nach der Schleife ausgeführt wird. Gerade einfache Warteschleifen, die eine feste Zahl von Taktzyklen warten, können so beschleunigt werden: der Rücksprung an den Blockanfang wird direkt ausgeführt, ohne zwischenzeitlich die Kontrolle an die Laufzeitumgebung abzugeben und auf Interrupts zu prüfen.

Auch schreibende Speicherzugriffe können meist gefahrlos durchgeführt werden. Ein Interrupthandler kann jedoch in diesem Fall eventuell durch die Schleife beeinflusst werden und sich durch die zusätzlich ausgeführten Schleifeniterationen fehlerhaft verhalten. Lesende Speicherzugriffe bergen dagegen ein erhebliches Risiko: eine Warteschleife, die auf einen Interrupt oder Timer wartet, terminiert eventuell nicht mehr. Da der lesende Zugriff auf Timervariablen und Statusregister meist mit speziellen Instruktionen erfolgt (LDH A, (a8) oder LDH A, (C)), werden in höheren Optimierungsstufen andere lesende Instruktionen in Schleifen erlaubt.

Die folgende Schleife führt ein memset auf einem Speicherbereich der Länge BC mit Endadresse HL durch und kann mit obigen Optimierungen unterbrechungsfrei ausgeführt werden:

\begin{lstlisting}
32			LD (HL-), A		; Byte setzen und HL dekrementieren
05			DEC B
20 FC		JR NZ, 0xFC		; an Anfang springen
0D			DEC C
20 F9		JR NZ, 0xF9		; an Anfang springen
\end{lstlisting}

Andere Optimierungen suchen mittels pattern matching nach bekannten und häufigen Instruktionsfolgen, die sich vereinfachen lassen. Das folgende häufig verwendete Muster wartet bis eine bestimmte Displayzeile gezeichnet wird\footnote{Es kann auch auf einen VBLANK gewartet werden, wenn die Zeile > 144 ist.}:

\begin{lstlisting}
F0 44		LDH A, (0x44)	; aktuelle Displayzeile lesen
FE ??		CP A, ??		; mit festem Wert vergleichen
20 FA		JR NZ, 0xFA		; an Anfang springen
\end{lstlisting}

In der Emulation kann stattdessen eine modifizierte HALT-Instruktion eingefügt werden, die statt auf einen Interrupt auf das Zeichnen der entsprechenden Displayzeile wartet.

%Schematischer Aufbau
%Designziel direkte Reads
%Registermapping
%Optimierung
%Beipielhafte Übersetzung einer Funktion
%Interrupts, Timer, etc.
%Memory Banking
\section{Grafik- / Audioausgabe}
%Grafikthread, Zeilenweiser Aufbau
%Audiobuffer, Auswertung mit jedem Frame
\section{Bedienung}
%Programmoptionen, Tastenbelegung, Savegames
\section{Debugger}
%unterstützte Befehle, visualisierung des Adressraums, patch, print, set, ...
\section{Kompatibilität}
%Screenshots, bekannte Probleme
\section{Ausblick / offene Punkte}
\end{document}